
# Array（陣列）
---
## 1. 定義與核心概念


**Array（陣列）**是一種**線性資料結構**，用來存放**同型別（通常）**的元素，並以**連續記憶體（contiguous memory）**配置。
其關鍵特性是：

* **Random Access（隨機存取）**：可透過索引（index）在 **O(1)** 時間讀取/寫入元素
* **連續記憶體**：元素在記憶體位置相鄰，利於快取（cache）效能
* **索引有序**：每個元素都有固定 index（常見從 0 開始）

---

## 2. Array 的記憶體模型

### 2.1 為什麼能 O(1) 存取？

陣列元素地址通常可表示為：

* `addr(A[i]) = base + i * sizeof(element)`

其中：

* `base`：陣列起始位置
* `i`：索引
* `sizeof(element)`：單一元素占用的位元組數

因此只要知道 `base` 和 `i`，就可以直接算出地址，不需要走訪。

---

## 3. 基本操作與時間複雜度

| 操作             | 說明          | 時間複雜度                   |
| -------------- | ----------- | ----------------------- |
| Access / Read  | 讀取 `A[i]`   | **O(1)**                |
| Update / Write | 寫入 `A[i]=x` | **O(1)**                |
| Search（未排序）    | 找某值         | **O(n)**                |
| Search（已排序）    | 二分搜尋        | **O(log n)**            |
| Insert（任意位置）   | 插入並右移       | **O(n)**                |
| Delete（任意位置）   | 刪除並左移       | **O(n)**                |
| Append（動態陣列）   | 尾端新增        | 平均 **O(1)**、最差 **O(n)** |

---

## 4. 靜態陣列 vs 動態陣列

### 4.1 靜態陣列（Static Array）

* 長度固定，建立後不可改變
* 記憶體一次配置完成
* 範例：C 的 `int a[10];`

特性：

* 優點：結構簡單、快、可預測
* 缺點：大小固定，容易浪費或不足

### 4.2 動態陣列（Dynamic Array）

* 長度可成長（例如：C++ `vector`、Java `ArrayList`、JS `Array`（語意上））
* 內部仍常用連續記憶體實作，但需要**擴容（resize）**

#### 擴容機制（典型）

* 當容量滿時，配置更大的新空間（常為原本的 2 倍）
* 將舊資料複製到新空間（O(n)）
* 更新指標並釋放舊空間

因此 `append` **平均 O(1)**，但會偶爾出現一次 **O(n)** 的拷貝。

---

## 5. 常見索引與邊界問題（Very Important）

### 5.1 Index 範圍

長度 `n` 的陣列，合法索引通常是：

* `0` 到 `n-1`

### 5.2 常見 bug

* Off-by-one：`i <= n` 寫成 `i < n`
* 讀到越界（Out-of-bounds）：存取 `A[n]`
* 空陣列處理：`n=0` 時仍存取 `A[0]`

建議習慣：

* 迴圈優先使用 `for (i = 0; i < n; i++)`
* 操作前檢查長度
* 特殊情況先處理（空陣列、單元素）

---

## 6. Array 相關技巧與典型題型

### 6.1 Prefix Sum（前綴和）

用於區間和查詢：

定義：

* `prefix[i] = A[0] + A[1] + ... + A[i-1]`（常用這種「長度 n+1」版本）

則區間 `[l, r)` 的總和：

* `sum(l, r) = prefix[r] - prefix[l]`

優點：多次區間查詢可從 O(n) 降到 O(1)。

---

### 6.2 Two Pointers（雙指標）

常用於：

* 已排序陣列找 pair sum
* 去重（remove duplicates）
* 滑動視窗（sliding window）

典型形式：

* `l` 從左，`r` 從右或從左跟著移動，透過條件調整指標。

---

### 6.3 Sliding Window（滑動視窗）

用於連續子陣列問題（最大/最小/最短等）：

* 維持一個 window `[l, r]`
* `r` 擴張以滿足條件，`l` 收縮以最佳化

複雜度通常可從 O(n²) 降到 O(n)。

---

### 6.4 In-place 操作

目標：不使用額外陣列（或 O(1) 額外空間）

常見：

* 反轉陣列（swap）
* 移除元素（用 write index 覆寫）
* 分區（partition / quicksort partition）

---

### 6.5 Sorting 與 Search 的關係

* 未排序：搜尋 O(n)
* 已排序：可二分 O(log n)，但插入/刪除仍可能 O(n)（因移動元素）

因此設計時常是取捨：

* **查詢多、更新少**：先排序，二分查詢
* **更新多**：可能改用 linked list、hash、tree 等

---

## 7. 2D Array（矩陣）

### 7.1 概念

2D Array 可視為「陣列的陣列」或「一維平坦化（flatten）」。

若使用一維平坦化表示矩陣 `rows x cols`：

* index 映射：`A[r][c]` 對應 `flat[r * cols + c]`

### 7.2 常見應用

* 圖像處理（像素矩陣）
* DP（動態規劃表）
* Grid BFS/DFS（迷宮、最短路）

---

## 8. Array 的優缺點

### 優點

* O(1) 隨機存取
* 記憶體連續，cache friendly
* 結構簡單，易於實作與理解

### 缺點

* 任意位置插入/刪除成本高（O(n)）
* 靜態陣列長度固定
* 動態陣列擴容有搬移成本（偶發 O(n)）

---

## 9. 重點清單

* 時間複雜度：Access O(1)、Insert/Delete O(n)
* 動態陣列 amortized O(1) append 的理由
* Prefix sum / sliding window / two pointers 基本套路
* 邊界處理：空陣列、越界、單元素
* 2D 轉 1D 映射（`r*cols+c`）

---
